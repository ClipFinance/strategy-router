const { expect } = require("chai");
const { ethers } = require("hardhat");
const { provider, deploy, parseUniform} = require("./utils");
const {
    setupFakeTokens,
    setupTokensLiquidityOnPancake,
    deployFakeStrategy,
    setupRouterParams,
    setupFakePrices,
    setupPancakePlugin
} = require("./shared/commonSetup");
const { formatUnits } = require("ethers/lib/utils");

describe("Test Batching (withdrawexploit)", function () {

    let owner, user1;

    // mock tokens with different decimals
    let usdc, usdt, busd;

    // helper functions to parse amounts of mock tokens
    let parseUsdc, parseUsdt, parseBusd;

    // core contracts
    let router, oracle, exchange, batching, receiptContract;

    // revert to test-ready state
    let snapshotId;
    // revert to fresh fork state
    let initialSnapshot;

    before(async function () {

        [owner, user1] = await ethers.getSigners();
        initialSnapshot = await provider.send("evm_snapshot");

        // deploy core contracts
        // ({ router, oracle, exchange, batching, receiptContract, sharesToken } = await setupCore());

        // Deploy Oracle
        oracle = await deploy("FakeOracle");
        // Deploy Exchange
        exchange = await deploy("Exchange");
        // Deploy StrategyRouterLib
        let routerLib = await deploy("StrategyRouterLib");
        // Deploy StrategyRouter
        let StrategyRouter = await ethers.getContractFactory("StrategyRouter", {
            libraries: {
                StrategyRouterLib: routerLib.address
            }
        });
        router = await StrategyRouter.deploy(exchange.address, oracle.address);
        await router.deployed();
        // Retrieve contracts that are deployed from StrategyRouter constructor
        batching = await ethers.getContractAt("Batching", await router.batching());
        receiptContract = await ethers.getContractAt("ReceiptNFT", await router.receiptContract());

        // deploy mock tokens where usdc has 18 decimals and usdt 6 decimals
        ({ usdc, usdt, busd, parseUsdc, parseUsdt, parseBusd } = await setupFakeTokens());

        // setup fake token token liquidity
        let amount = (1_000_000).toString();
        await setupTokensLiquidityOnPancake(usdc, busd, amount);
        await setupTokensLiquidityOnPancake(busd, usdt, amount);
        await setupTokensLiquidityOnPancake(usdc, usdt, amount);

        await setupRouterParams(router, oracle, exchange);
        await setupFakePrices(oracle, usdc, usdt, busd);
        await setupPancakePlugin(exchange, usdc, usdt, busd);

        // setup user1 tokens balance
        await usdc.transfer(user1.address, parseUsdc("1500"));
        await usdt.transfer(user1.address, parseUsdt("1000"));

        // setup supported tokens
        await router.setSupportedToken(usdc.address, true);
        await router.setSupportedToken(usdt.address, true);

        // add fake strategies
        await deployFakeStrategy({ router, token: usdc });
        await deployFakeStrategy({ router, token: usdt });
    });

    beforeEach(async function () {
        snapshotId = await provider.send("evm_snapshot");
    });

    afterEach(async function () {
        await provider.send("evm_revert", [snapshotId]);
    });

    after(async () => {
        await provider.send("evm_revert", [initialSnapshot]);
    });

    // TODO deposit()
    //   happy path: when funds are deposited batch, receiptNFT is minted and correct values assigned (non-zero/non-default)
    //   corner cases below:
    //     not supported token is deposited, transaction reverted
    //     user deposits deppeged token that numerically match minimum amount, transaction should revert
    //     deposited token has different decimal places (3, 6, 12, 21), expected receipt to have correctly normalized amount value

    //  TODO getBatchingTotalUsdValue()
    //    happy paths: 1 supported token, 3 supported tokens
    //    corner cases below:
    //      within 3 tokens we have 1 token depegged with $0.5 per token, second token with different decimal amount (10^12)
    //       and third is normal

    it("Should withdraw correct amount from receipts with 2 different tokens and decimal points", async function() {

        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));

        // deposit 1000 USDT with decimals 10^6
        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000"));
        // another deposit 1500 USDC with decimals 10^18
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500"));
        // check that user1 has 2 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(2);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batching.sol
        let receipt1Data = await receiptContract.getReceipt(0);
        expect(receipt1Data.amount).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals
        let receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("1500"));

        const batchingUsdtBalanceBefore = await usdt.balanceOf(batching.address); // 1000.000_000
        const batchingUsdcBalanceBefore = await usdc.balanceOf(batching.address); // 1500.000_000_000_000_000_000
        const user1UsdtBalanceBefore = await usdt.balanceOf(user1.address);

        // we withdraw from batching, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2]
        //  arg 2: usdt address
        //  arg 3: amounts [1000*10^18, 700*10^18]
        const receiptIds = [0, 1];

        // 1000 usdt = $990. 700 usdc = $700
        const receiptTokenAmounts = [parseUniform("1000"), parseUniform("700")];
        /*
        * Batching#withdraw():
        * 1 usdt = $0.99. Inside batching withdraw we calculate USD value to withdraw in requested tokens.
        * we withdraw 1000 usdt + 700 usdc = $1690. First receipt will be burned.
        * second receipt will have 800 usdc left out of 1500 usdc (1500-700)
        * Batching#_withdraw():
        * withdrawing $1690 while we have in batching $2490 consists of 1000 usdt ($990) and 1500 usdc ($1500)
        * withdrawal token usdt does not have $1690 in balance, so we deduct from usdt batching balance of 1000 usdt ($990)
        * remaining to withdraw 700 usdc in other than usdt token - we have 1500 usdc ($1500)
        * so we need to receive $700 in usdt minus fees. convert 700 usdc to usdt
        * deduct 0.25% fee from 700
        * 0.25% or 0.0025 with 18 decimals
        * */
        await router.connect(user1).withdrawFromBatching(receiptIds, usdt.address, receiptTokenAmounts);
        // we check that receipt 1 was burned and receipt 2 amount was deducted by the correct amount 500*10^18
        // TODO https://stackoverflow.com/a/72146474 should fail here, but only pass with NonExistingToken()
        await expect(receiptContract.getReceipt(0)).to.be.revertedWith("InvalidQueryRange()");

        receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("800"));

        //  batching balance was decreased by 1000 usdt and 700 usdc
        const batchingUsdtBalanceAfter = await usdt.balanceOf(batching.address);
        expect(batchingUsdtBalanceAfter).to.be.eq(parseUsdt("0"));
        expect(batchingUsdtBalanceBefore.sub(batchingUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchingUsdcBalanceAfter = await usdc.balanceOf(batching.address);
        expect(batchingUsdcBalanceAfter).to.be.eq(parseUsdc("800"));
        expect(batchingUsdcBalanceBefore.sub(batchingUsdcBalanceAfter)).to.be.eq(parseUsdc("700"));

        const uniswapRouter = await ethers.getContractAt("IUniswapV2Router02", hre.networkVariables.uniswapRouter);
        const uniswapFactoryAddress = await uniswapRouter.factory();
        expect(uniswapFactoryAddress).to.not.be.eq("0x0000000000000000000000000000000000000000");
        const uniswapFactory = await ethers.getContractAt("IUniswapV2Factory", uniswapFactoryAddress);
        const uniswapPairAddress = await uniswapFactory.getPair(usdc.address, usdt.address);
        const uniswapPair = await ethers.getContractAt("IUniswapV2Pair", uniswapPairAddress);
        const uniswapPairToken0 = await uniswapPair.token0();

        expect(uniswapPairToken0).to.be.eq(usdc.address);

        const [reserveUSDC, reserveUSDT] = await uniswapPair.getReserves();

        // 9975 TODO see why there's slight mismatch. Write problem and what was done so far
        const convertedAmount = parseUsdc((700*0.9975).toString()).mul(reserveUSDT).div(reserveUSDC);
        // expect(convertedAmount).to.be.eq(parseUsdt("697.762787"));

        //  user balance was increased by 1700 usdt, excludes fee on 700 converted usdt only
        // TODO AssertionError: Expected "1697.762_787" to be equal 1700.000_000
        const user1UsdtBalanceAfter = await usdt.balanceOf(user1.address);
        // expect(user1UsdtBalanceAfter.sub(user1UsdtBalanceBefore)).to.be.eq(parseUsdt("1700"));

    });

    // deposit 1000 usdt, 1500 usdc, 2000 busd. withdraw 4000 busd.
    it("Should withdraw correct amount from receipts with 3 different tokens and decimal points", async function() {

        // in addition to before() we give busd to user as well
        await busd.transfer(user1.address, parseBusd("2000"));
        await router.setSupportedToken(busd.address, true);

        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));
        await busd.connect(user1).approve(router.address, parseBusd("2000"));

        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000")); // $990
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500")); // $1500
        await router.connect(user1).depositToBatch(busd.address, parseBusd("2000")); // $2020

        // check that user1 has 3 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(3);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batching.sol
        let receipt1Data = await receiptContract.getReceipt(0);
        expect(receipt1Data.amount).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals. skip receipt 3 to save time.
        let receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("1500"));

        const batchingUsdtBalanceBefore = await usdt.balanceOf(batching.address);
        const batchingUsdcBalanceBefore = await usdc.balanceOf(batching.address);
        const batchingBusdBalanceBefore = await busd.balanceOf(batching.address);

        let { totalBalance, } = await router.getBatchingValueUsd();
        expect(totalBalance).to.be.equal(parseUniform("4510"));

        // we withdraw from batching, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2, 3]
        //  arg 2: usdt address
        //  arg 3: amounts [1000, 1500, 1500]
        const receiptIds = [0, 1, 2];
        const receiptTokenAmounts = [parseUniform("1000"), parseUniform("1500"), parseUniform("1500")];
        await router.connect(user1).withdrawFromBatching(receiptIds, usdt.address, receiptTokenAmounts);

        // receipts 1 and 2 were burned
        await expect(receiptContract.getReceipt(0)).to.be.revertedWith("InvalidQueryRange()");
        // receipt2Data = await receiptContract.getReceipt(1);
        await expect(receiptContract.getReceipt(1)).to.be.revertedWith("NonExistingToken()");

        // we check receipt 2 has remaining amount of 500 (2000-1500)
        let receipt3Data = await receiptContract.getReceipt(2);
        expect(receipt3Data.amount).to.be.eq(parseUniform("500"));

        //  batching balance was decreased by 1000 usdt and 700 usdc
        const batchingUsdtBalanceAfter = await usdt.balanceOf(batching.address);
        expect(batchingUsdtBalanceAfter).to.be.eq(parseUsdt("0"));
        expect(batchingUsdtBalanceBefore.sub(batchingUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchingUsdcBalanceAfter = await usdc.balanceOf(batching.address);
        expect(batchingUsdcBalanceAfter).to.be.eq(parseUsdc("0"));
        expect(batchingUsdcBalanceBefore.sub(batchingUsdcBalanceAfter)).to.be.eq(parseUsdc("1500"));

        const batchingBusdBalanceAfter = await busd.balanceOf(batching.address);
        expect(batchingBusdBalanceAfter).to.be.eq(parseBusd("500"));
        expect(batchingBusdBalanceBefore.sub(batchingBusdBalanceAfter)).to.be.eq(parseBusd("1500"));

        totalBalance = (await router.getBatchingValueUsd()).totalBalance;
        expect(totalBalance).to.be.equal(parseUniform("505"));

        // TODO AssertionError: Expected "3988.029_160" to be equal 4000.000_000
        const user1UsdtBalanceAfter = await usdt.balanceOf(user1.address);
        // TODO uncomment expect(user1UsdtBalanceAfter).to.be.eq(parseUsdt("4000"));
    });

    /* TODO implement. exchange token price and oracle price deviates -
        oracle returns price $0.8, but exchange returns $1, so there's mismatch.
        user1 deposits 1000 USDC, 100 BUSD, 200 USDT.
        user2 deposits 100 FRAX
        total deposits in batch $1400 (assuming $1 per token)
        user1 wants to withdraw 1250 USDC
        assumption is that remaining FRAX will be also converted
        there will be overflow of `valueToWithdrawUsd` and 2nd user's funds will swapped
        and transferred to the first user
    */
    it("Should withdraw correct amount from receipt when stablecoin price depegged", async function() {

        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));

        // deposit 1000 USDT with decimals 10^6
        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000"));
        // another deposit 1500 USDC with decimals 10^18
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500"));
        // check that user1 has 2 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(2);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batching.sol
        let receipt1Data = await receiptContract.getReceipt(0);
        expect(receipt1Data.amount).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals
        let receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("1500"));

        const batchingUsdtBalanceBefore = await usdt.balanceOf(batching.address);
        const batchingUsdcBalanceBefore = await usdc.balanceOf(batching.address);
        const user1UsdcBalanceBefore = await usdc.balanceOf(user1.address);

        // we withdraw from batching, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2]
        //  arg 2: usdt address
        //  arg 3: amounts [1000*10^18, 500*10^18]
        const receiptIds = [0, 1];
        const receiptTokenAmounts = [parseUniform("1000"), parseUniform("700")];
        await router.connect(user1).withdrawFromBatching(receiptIds, usdt.address, receiptTokenAmounts);
        // we check that
        //  receipt 1 was burned and receipt 2 amount was deducted by the correct amount 500*10^18
        // TODO https://stackoverflow.com/a/72146474 should fail here, but only pass with NonExistingToken()
        await expect(receiptContract.getReceipt(0)).to.be.revertedWith("InvalidQueryRange()");
        receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("800"));

        //  batching balance was decreased by 1000 usdt and 700 usdc
        const batchingUsdtBalanceAfter = await usdt.balanceOf(batching.address);
        // TODO AssertionError: Expected "191919191" to be equal 1000000000
        expect(batchingUsdtBalanceBefore.sub(batchingUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchingUsdcBalanceAfter = await usdc.balanceOf(batching.address);
        // TODO AssertionError: Expected "1500000000000000000000" to be equal 700000000000000000000
        expect(batchingUsdcBalanceBefore.sub(batchingUsdcBalanceAfter)).to.be.eq(parseUsdc("700"));

        //  user balance was increased by 1700 usdc
        // TODO AssertionError: Expected "0" to be equal 1700000000000000000000
        const user1UsdcBalanceAfter = await usdc.balanceOf(user1.address);
        expect(user1UsdcBalanceAfter.sub(user1UsdcBalanceBefore)).to.be.eq(parseUsdc("1700"));
        // after that withdraw 1500 USDC we expect first deposit to be burned and partially second deposit burned

    });

    it("exploit on depeg", async function() {

        await usdc.approve(router.address, parseUsdc("100000000"));
        await usdt.approve(router.address, parseUsdt("100000000"));

        // deposit 10000 USDT with decimals 10^6
        await router.depositToBatch(usdt.address, parseUsdt("10000"));
        await router.allocateToStrategies();

        // deposit 10000 USDT with decimals 10^6
        // await router.depositToBatch(usdt.address, parseUsdt("10000"));
        // await router.allocateToStrategies();

        await router.depositToBatch(usdt.address, parseUsdt("10000"));
        await oracle.setPrice(usdc.address, parseUsdc("0.9"));
        // console.log(await router.getStrategiesValue());
        await router.allocateToStrategies();
        await oracle.setPrice(usdc.address, parseUsdc("1.1"));

        // we withdraw from batching, in withdrawal call we provide:
        console.log("receipts", (await receiptContract.getTokensOfOwner(owner.address)).toString());

        let receiptIds = [0];
        let shares = await router.calculateSharesFromReceipts(receiptIds);
        let balanceBefore = await usdt.balanceOf(owner.address); 
        await router.withdrawFromStrategies(receiptIds, usdt.address, shares);
        let balanceAfter = await usdt.balanceOf(owner.address); 
        // without depeg this prints 9963.306044
        console.log(formatUnits(balanceAfter.sub(balanceBefore), 6));

        receiptIds = [1];
        shares = await router.calculateSharesFromReceipts(receiptIds);
        balanceBefore = await usdt.balanceOf(owner.address); 
        await router.withdrawFromStrategies(receiptIds, usdt.address, shares);
        balanceAfter = await usdt.balanceOf(owner.address); 
        // without depeg this prints 9963.306044
        console.log(formatUnits(balanceAfter.sub(balanceBefore), 6));
        // peg pring:             9987.187169 and 9963.306044
        // depeg 0.5 print:       9978.918768 and 9971.574445
        // depeg 2.0:             9995.462145 and 9955.031068
        // depeg 0.5 then 2.0:    7499.495221 and 12450.952491
        // depege 0.9 then 1.1:   9535.306444 and 10415.176948
    });

    //  TODO rebalance()
    //    happy paths:
    //    corner cases below:

    // TODO setSupportedToken()
    //   happy paths: add token, token added, is listed in supported tokens
    //    corner cases below:
    //     pass same token multiple times, test function is idempotent
    //     pass address that is not a token
    //   suspended until clarification: happy paths delete token: test
    //     corner cases below:
    //       token is still in already in strategy
});