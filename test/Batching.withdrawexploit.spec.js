const { expect } = require("chai");
const { ethers } = require("hardhat");
const { provider, deploy, parseUniform} = require("./utils");
const {
    setupFakeTokens,
    setupTokensLiquidityOnPancake,
    setupTestParams,
    deployFakeStrategy,
    setupRouterParams,
    setupFakePrices,
    setupPancakePlugin
} = require("./shared/commonSetup");

describe("Test Batching", function () {

    let owner, user1;

    // mock tokens with different decimals
    let usdc, usdt;

    // helper functions to parse amounts of mock tokens
    let parseUsdc, parseUsdt;

    // core contracts
    let router, oracle, exchange, batching, receiptContract;

    // revert to test-ready state
    let snapshotId;
    // revert to fresh fork state
    let initialSnapshot;

    before(async function () {

        [owner, user1] = await ethers.getSigners();
        initialSnapshot = await provider.send("evm_snapshot");

        // deploy core contracts
        // ({ router, oracle, exchange, batching, receiptContract, sharesToken } = await setupCore());

        // Deploy Oracle
        oracle = await deploy("FakeOracle");
        // Deploy Exchange
        exchange = await deploy("Exchange");
        // Deploy StrategyRouterLib
        let routerLib = await deploy("StrategyRouterLib");
        // Deploy StrategyRouter
        let StrategyRouter = await ethers.getContractFactory("StrategyRouter", {
            libraries: {
                StrategyRouterLib: routerLib.address
            }
        });
        router = await StrategyRouter.deploy(exchange.address, oracle.address);
        await router.deployed();
        // Retrieve contracts that are deployed from StrategyRouter constructor
        batching = await ethers.getContractAt("Batching", await router.batching());
        receiptContract = await ethers.getContractAt("ReceiptNFT", await router.receiptContract());

        // deploy mock tokens where usdc has 18 decimals and usdt 6 decimals
        ({ usdc, usdt, busd, parseUsdc, parseUsdt } = await setupFakeTokens());

        // setup fake token token liquidity
        let amount = (1_000_000).toString();
        await setupTokensLiquidityOnPancake(usdc, busd, amount);
        await setupTokensLiquidityOnPancake(busd, usdt, amount);
        await setupTokensLiquidityOnPancake(usdc, usdt, amount);

        await setupRouterParams(router, oracle, exchange);
        await setupFakePrices(oracle, usdc, usdt, busd);
        await setupPancakePlugin(exchange, usdc, usdt, busd);

        // setup user1 tokens balance
        await usdc.transfer(user1.address, parseUsdc("1500"));
        await usdt.transfer(user1.address, parseUsdt("1000"));

        // setup supported tokens
        await router.setSupportedToken(usdc.address, true);
        await router.setSupportedToken(usdt.address, true);

        // add fake strategies
        await deployFakeStrategy({ router, token: usdc });
        await deployFakeStrategy({ router, token: usdt });
    });

    beforeEach(async function () {
        snapshotId = await provider.send("evm_snapshot");
    });

    afterEach(async function () {
        await provider.send("evm_revert", [snapshotId]);
    });

    after(async () => {
        await provider.send("evm_revert", [initialSnapshot]);
    });

    // TODO deposit()
    //   happy path: when funds are deposited batch, receiptNFT is minted and correct values assigned (non-zero/non-default)
    //   corner cases below:
    //     not supported token is deposited, transaction reverted
    //     user deposits deppeged token that numerically match minimum amount, transaction should revert
    //     deposited token has different decimal places (3, 6, 12, 21), expected receipt to have correctly normalized amount value

    //  TODO getBatchingTotalUsdValue()
    //    happy paths: 1 supported token, 3 supported tokens
    //    corner cases below:
    //      within 3 tokens we have 1 token depegged with $0.5 per token, second token with different decimal amount (10^12)
    //       and third is normal

    // TODO withdraw()
    //    happy paths:
    //    corner cases below:
    //      deposit 1000 USDT with decimals 10^6
    //      another deposit 1500 USDC with decimals 10^18
    //      after that withdraw 1000 USDT and 500 USDC we expect first deposit to be burned and partially second deposit burned
    it("Should withdraw correct amount from receipts with different tokens and decimal points", async function() {

        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));

        // deposit 1000 USDT with decimals 10^6
        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000"));
        // another deposit 1500 USDC with decimals 10^18
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500"));
        // check that user1 has 2 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(2);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batching.sol
        let receipt1Data = await receiptContract.getReceipt(0);
        expect(receipt1Data.amount).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals
        let receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("1500"));

        const batchingUsdtBalanceBefore = await usdt.balanceOf(batching.address); // 1000.000_000
        const batchingUsdcBalanceBefore = await usdc.balanceOf(batching.address); // 1500.000_000_000_000_000_000
        const user1UsdtBalanceBefore = await usdt.balanceOf(user1.address);

        // we withdraw from batching, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2]
        //  arg 2: usdt address
        //  arg 3: amounts [1000*10^18, 700*10^18]
        const receiptIds = [0, 1];
        const receiptTokenAmounts = [parseUniform("1000"), parseUniform("700")];
        /*
        * Batching#withdraw():
        * 1 usdt = $0.99. Inside batching withdraw we calculate USD value to withdraw in requested tokens.
        * we withdraw 1000+700 usdt = $1683. First receipt will be burned.
        * second receipt will have 800 usdc left out of 1500 usdc (1500-700)
        * Batching#_withdraw():
        * withdrawing $1683 while we have in batching $2490 consists of 1000 usdt ($990) and 1500 usdc ($1500)
        * withdrawal token usdt does not have $1683 in balance, so we deduct from usdt batching balance of 1000 usdt ($990)
        * remaining to withdraw 700 usdt in other than usdt token - we have 1500 usdc ($1500)
        * so we need to receive $693 in usdt minus fees. 693
        * deduct 0.25% fee from 700
        * 0.25% or 0.0025 with 18 decimals
        * */
        await router.connect(user1).withdrawFromBatching(receiptIds, usdt.address, receiptTokenAmounts);
        // we check that receipt 1 was burned and receipt 2 amount was deducted by the correct amount 500*10^18
        // TODO https://stackoverflow.com/a/72146474 should fail here, but only pass with NonExistingToken()
        await expect(receiptContract.getReceipt(0)).to.be.revertedWith("InvalidQueryRange()");

        receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("800"));

        //  batching balance was decreased by 1000 usdt and 700 usdc
        const batchingUsdtBalanceAfter = await usdt.balanceOf(batching.address);
        expect(batchingUsdtBalanceAfter).to.be.eq(parseUsdt("0"));
        expect(batchingUsdtBalanceBefore.sub(batchingUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchingUsdcBalanceAfter = await usdc.balanceOf(batching.address);
        expect(batchingUsdcBalanceAfter).to.be.eq(parseUsdc("800"));
        expect(batchingUsdcBalanceBefore.sub(batchingUsdcBalanceAfter)).to.be.eq(parseUsdc("700"));

        //  user balance was increased by 1700 usdt, excludes fee on 700 converted usdt only
        // TODO AssertionError: Expected "1697.762_787" to be equal 1700.000_000
        const user1UsdtBalanceAfter = await usdt.balanceOf(user1.address);
        expect(user1UsdtBalanceAfter.sub(user1UsdtBalanceBefore)).to.be.eq(parseUsdt("1700"));
        // after that withdraw 1500 USDC we expect first deposit to be burned and partially second deposit burned

    });

    // TODO implement
    it("Should withdraw correct amount from receipt when stablecoin price depegged", async function() {

        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));

        // deposit 1000 USDT with decimals 10^6
        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000"));
        // another deposit 1500 USDC with decimals 10^18
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500"));
        // check that user1 has 2 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(2);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batching.sol
        let receipt1Data = await receiptContract.getReceipt(0);
        expect(receipt1Data.amount).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals
        let receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("1500"));

        const batchingUsdtBalanceBefore = await usdt.balanceOf(batching.address);
        const batchingUsdcBalanceBefore = await usdc.balanceOf(batching.address);
        const user1UsdcBalanceBefore = await usdc.balanceOf(user1.address);

        // we withdraw from batching, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2]
        //  arg 2: usdt address
        //  arg 3: amounts [1000*10^18, 500*10^18]
        const receiptIds = [0, 1];
        const receiptTokenAmounts = [parseUniform("1000"), parseUniform("700")];
        await router.connect(user1).withdrawFromBatching(receiptIds, usdt.address, receiptTokenAmounts);
        // we check that
        //  receipt 1 was burned and receipt 2 amount was deducted by the correct amount 500*10^18
        // TODO https://stackoverflow.com/a/72146474 should fail here, but only pass with NonExistingToken()
        await expect(receiptContract.getReceipt(0)).to.be.revertedWith("InvalidQueryRange()");
        receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("800"));

        //  batching balance was decreased by 1000 usdt and 700 usdc
        const batchingUsdtBalanceAfter = await usdt.balanceOf(batching.address);
        // TODO AssertionError: Expected "191919191" to be equal 1000000000
        expect(batchingUsdtBalanceBefore.sub(batchingUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchingUsdcBalanceAfter = await usdc.balanceOf(batching.address);
        // TODO AssertionError: Expected "1500000000000000000000" to be equal 700000000000000000000
        expect(batchingUsdcBalanceBefore.sub(batchingUsdcBalanceAfter)).to.be.eq(parseUsdc("700"));

        //  user balance was increased by 1700 usdc
        // TODO AssertionError: Expected "0" to be equal 1700000000000000000000
        const user1UsdcBalanceAfter = await usdc.balanceOf(user1.address);
        expect(user1UsdcBalanceAfter.sub(user1UsdcBalanceBefore)).to.be.eq(parseUsdc("1700"));
        // after that withdraw 1500 USDC we expect first deposit to be burned and partially second deposit burned

    });

    /* TODO implement. exchange token price and oracle price deviates -
        oracle returns price $0.8, but exchange returns $1, so there's mismatch.
        user1 deposits 1000 USDC, 100 BUSD, 200 USDT.
        user2 deposits 100 FRAX
        total deposits in batch $1400 (assuming $1 per token)
        user1 wants to withdraw 1250 USDC
        assumption is that remaining FRAX will be also converted
        there will be overflow of `valueToWithdrawUsd` and 2nd user's funds will swapped
        and transferred to the first user
    */
    it("Should withdraw correct amount from receipt when stablecoin price depegged", async function() {

        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));

        // deposit 1000 USDT with decimals 10^6
        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000"));
        // another deposit 1500 USDC with decimals 10^18
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500"));
        // check that user1 has 2 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(2);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batching.sol
        let receipt1Data = await receiptContract.getReceipt(0);
        expect(receipt1Data.amount).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals
        let receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("1500"));

        const batchingUsdtBalanceBefore = await usdt.balanceOf(batching.address);
        const batchingUsdcBalanceBefore = await usdc.balanceOf(batching.address);
        const user1UsdcBalanceBefore = await usdc.balanceOf(user1.address);

        // we withdraw from batching, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2]
        //  arg 2: usdt address
        //  arg 3: amounts [1000*10^18, 500*10^18]
        const receiptIds = [0, 1];
        const receiptTokenAmounts = [parseUniform("1000"), parseUniform("700")];
        await router.connect(user1).withdrawFromBatching(receiptIds, usdt.address, receiptTokenAmounts);
        // we check that
        //  receipt 1 was burned and receipt 2 amount was deducted by the correct amount 500*10^18
        // TODO https://stackoverflow.com/a/72146474 should fail here, but only pass with NonExistingToken()
        await expect(receiptContract.getReceipt(0)).to.be.revertedWith("InvalidQueryRange()");
        receipt2Data = await receiptContract.getReceipt(1);
        expect(receipt2Data.amount).to.be.eq(parseUniform("800"));

        //  batching balance was decreased by 1000 usdt and 700 usdc
        const batchingUsdtBalanceAfter = await usdt.balanceOf(batching.address);
        // TODO AssertionError: Expected "191919191" to be equal 1000000000
        expect(batchingUsdtBalanceBefore.sub(batchingUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchingUsdcBalanceAfter = await usdc.balanceOf(batching.address);
        // TODO AssertionError: Expected "1500000000000000000000" to be equal 700000000000000000000
        expect(batchingUsdcBalanceBefore.sub(batchingUsdcBalanceAfter)).to.be.eq(parseUsdc("700"));

        //  user balance was increased by 1700 usdc
        // TODO AssertionError: Expected "0" to be equal 1700000000000000000000
        const user1UsdcBalanceAfter = await usdc.balanceOf(user1.address);
        expect(user1UsdcBalanceAfter.sub(user1UsdcBalanceBefore)).to.be.eq(parseUsdc("1700"));
        // after that withdraw 1500 USDC we expect first deposit to be burned and partially second deposit burned

    });

    //  TODO rebalance()
    //    happy paths:
    //    corner cases below:

    // TODO setSupportedToken()
    //   happy paths: add token, tokken added, is listed in supported tokens
    //    corner cases below:
    //     pass same token multiple times, test function is idempotent
    //     pass address that is not a token
    //   suspended until clarification: happy paths delete token: test
    //     corner cases below:
    //       token is still in already in strategy
});