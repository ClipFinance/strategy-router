const { expect } = require("chai");
const { ethers } = require("hardhat");
const { provider, deploy, parseUniform} = require("./utils");
const {
    setupCore,
    setupFakeTokens,
    setupTokensLiquidityOnPancake,
    deployFakeStrategy,
    setupRouterParams,
    setupFakePrices,
    setupPancakePlugin, setupTestParams
} = require("./shared/commonSetup");
const { formatUnits } = require("ethers/lib/utils");
const { BigNumber } = require("ethers");

describe("Test Batch (withdrawexploit)", function () {

    let owner, user1;

    // mock tokens with different decimals
    let usdc, usdt, busd;

    // helper functions to parse amounts of mock tokens
    let parseUsdc, parseUsdt, parseBusd;

    // core contracts
    let router, oracle, exchange, batch, receiptContract;

    // revert to test-ready state
    let snapshotId;
    // revert to fresh fork state
    let initialSnapshot;

    before(async function () {

        [owner, user1] = await ethers.getSigners();
        initialSnapshot = await provider.send("evm_snapshot");

        // deploy core contracts
        ({ router, oracle, exchange, batch, receiptContract } = await setupCore());

        // deploy mock tokens where usdc has 18 decimals and usdt 6 decimals
        ({ usdc, usdt, busd, parseUsdc, parseUsdt, parseBusd } = await setupFakeTokens());

        // setup fake token token liquidity
        let amount = (1_000_000).toString();
        await setupTokensLiquidityOnPancake(usdc, busd, amount);
        await setupTokensLiquidityOnPancake(busd, usdt, amount);
        await setupTokensLiquidityOnPancake(usdc, usdt, amount);

        // setup params for testing
        await setupTestParams(router, oracle, exchange, usdc, usdt, busd);

        // setup user1 tokens balance
        await usdc.transfer(user1.address, parseUsdc("1500"));
        await usdt.transfer(user1.address, parseUsdt("1000"));

        // setup supported tokens
        await router.setSupportedToken(usdc.address, true);
        await router.setSupportedToken(usdt.address, true);

        // add fake strategies
        await deployFakeStrategy({ router, token: usdc });
        await deployFakeStrategy({ router, token: usdt });
    });

    beforeEach(async function () {
        snapshotId = await provider.send("evm_snapshot");
    });

    afterEach(async function () {
        await provider.send("evm_revert", [snapshotId]);
    });

    after(async () => {
        await provider.send("evm_revert", [initialSnapshot]);
    });

    // TODO deposit()
    //   happy path: when funds are deposited batch, receiptNFT is minted and correct values assigned (non-zero/non-default)
    //   corner cases below:
    //     not supported token is deposited, transaction reverted
    //     user deposits deppeged token that numerically match minimum amount, transaction should revert
    //     deposited token has different decimal places (3, 6, 12, 21), expected receipt to have correctly normalized amount value

    //  TODO getBatchTotalUsdValue()
    //    happy paths: 1 supported token, 3 supported tokens
    //    corner cases below:
    //      within 3 tokens we have 1 token depegged with $0.5 per token, second token with different decimal amount (10^12)
    //       and third is normal

    it("Should withdraw correct amount from receipts with 2 different tokens and decimal points", async function() {

        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));

        // deposit 1000 USDT with decimals 10^6
        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000"));
        // another deposit 1500 USDC with decimals 10^18
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500"));
        // check that user1 has 2 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(2);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batch.sol
        let receipt1Data = await receiptContract.getReceipt(
          BigNumber.from(0)
        );
        expect(receipt1Data.tokenAmountUniform).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals
        let receipt2Data = await receiptContract.getReceipt(
          BigNumber.from(1)
        );
        expect(receipt2Data.tokenAmountUniform).to.be.eq(parseUniform("1500"));

        const batchUsdtBalanceBefore = await usdt.balanceOf(batch.address); // 1000.000_000
        const batchUsdcBalanceBefore = await usdc.balanceOf(batch.address); // 1500.000_000_000_000_000_000

        // we withdraw from batch, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2]
        const receiptIds = [BigNumber.from(0), BigNumber.from(1)];

        await router.connect(user1).withdrawFromBatch(receiptIds);
        // TODO https://stackoverflow.com/a/72146474 should fail here, but only pass with NonExistingToken()
        await expect(
          receiptContract.getReceipt(
            BigNumber.from(0)
          )
        ).to.be.revertedWith("NonExistingToken()");
        await expect(
          receiptContract.getReceipt(
            BigNumber.from(1)
          )
        ).to.be.revertedWith("NonExistingToken()");

        //  batch balance was decreased by 1000 usdt and 700 usdc
        const batchUsdtBalanceAfter = await usdt.balanceOf(batch.address);
        expect(batchUsdtBalanceAfter).to.be.eq(parseUsdt("0"));
        expect(batchUsdtBalanceBefore.sub(batchUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchUsdcBalanceAfter = await usdc.balanceOf(batch.address);
        expect(batchUsdcBalanceAfter).to.be.eq(parseUsdc("0"));
        expect(batchUsdcBalanceBefore.sub(batchUsdcBalanceAfter)).to.be.eq(parseUsdc("1500"));

        expect(await usdt.balanceOf(user1.address)).to.be.eq(parseUsdt("1000"));
        expect(await usdc.balanceOf(user1.address)).to.be.eq(parseUsdc("1500"));
    });

    // deposit 1000 usdt, 1500 usdc, 2000 busd. withdraw 4000 busd.
    it("Should withdraw correct amount from receipts with 3 different tokens and decimal points", async function() {

        // in addition to before() we give busd to user as well
        await busd.transfer(user1.address, parseBusd("2000"));
        await router.setSupportedToken(busd.address, true);

        await usdt.connect(user1).approve(router.address, parseUsdt("1000"));
        await usdc.connect(user1).approve(router.address, parseUsdc("1500"));
        await busd.connect(user1).approve(router.address, parseBusd("2000"));

        await router.connect(user1).depositToBatch(usdt.address, parseUsdt("1000")); // $990
        await router.connect(user1).depositToBatch(usdc.address, parseUsdc("1500")); // $1500
        await router.connect(user1).depositToBatch(busd.address, parseBusd("2000")); // $2020

        // check that user1 has 3 receipts
        const user1ReceiptAmounts = await receiptContract.balanceOf(user1.address);
        expect(user1ReceiptAmounts).to.be.eq(3);
        // we check receipt 1 has amount in 10^18 decimals due to uniform in Batch.sol
        let receipt1Data = await receiptContract.getReceipt(
          BigNumber.from(0)
        );
        expect(receipt1Data.tokenAmountUniform).to.be.eq(parseUniform("1000"));

        // we check receipt 2 has amount in 10^18 decimals. skip receipt 3 to save time.
        let receipt2Data = await receiptContract.getReceipt(
          BigNumber.from(1)
        );
        expect(receipt2Data.tokenAmountUniform).to.be.eq(parseUniform("1500"));

        // we check receipt 2 has amount in 10^18 decimals. skip receipt 3 to save time.
        let receipt3Data = await receiptContract.getReceipt(
          BigNumber.from(2)
        );
        expect(receipt3Data.tokenAmountUniform).to.be.eq(parseUniform("2000"));

        const batchUsdtBalanceBefore = await usdt.balanceOf(batch.address);
        const batchUsdcBalanceBefore = await usdc.balanceOf(batch.address);
        const batchBusdBalanceBefore = await busd.balanceOf(batch.address);

        let totalBalanceAfterDeposit = (await router.getBatchValueUsd()).totalBalance;
        expect(totalBalanceAfterDeposit).to.be.equal(parseUniform("4510"));

        // we withdraw from batch, in withdrawal call we provide:
        //  arg 1: receipt ids [1, 2, 3]
        const receiptIds = [BigNumber.from(0), BigNumber.from(1), BigNumber.from(2)];
        await router.connect(user1).withdrawFromBatch(receiptIds);

        // receipts 1 and 2 were burned
        await expect(receiptContract.getReceipt(
          BigNumber.from(0)
        )).to.be.revertedWith("NonExistingToken()");
        await expect(receiptContract.getReceipt(
          BigNumber.from(1)
        )).to.be.revertedWith("NonExistingToken()");
        await expect(receiptContract.getReceipt(
          BigNumber.from(2)
        )).to.be.revertedWith("NonExistingToken()");

        //  batch balance was decreased by 1000 usdt and 700 usdc
        const batchUsdtBalanceAfter = await usdt.balanceOf(batch.address);
        expect(batchUsdtBalanceAfter).to.be.eq(parseUsdt("0"));
        expect(batchUsdtBalanceBefore.sub(batchUsdtBalanceAfter)).to.be.eq(parseUsdt("1000"));

        const batchUsdcBalanceAfter = await usdc.balanceOf(batch.address);
        expect(batchUsdcBalanceAfter).to.be.eq(parseUsdc("0"));
        expect(batchUsdcBalanceBefore.sub(batchUsdcBalanceAfter)).to.be.eq(parseUsdc("1500"));

        const batchBusdBalanceAfter = await busd.balanceOf(batch.address);
        expect(batchBusdBalanceAfter).to.be.eq(parseBusd("0"));
        expect(batchBusdBalanceBefore.sub(batchBusdBalanceAfter)).to.be.eq(parseBusd("2000"));

        let totalBalanceAfterWithdraw = (await router.getBatchValueUsd()).totalBalance;
        expect(totalBalanceAfterDeposit.sub(totalBalanceAfterWithdraw)).to.be.equal(parseUniform("4510"));

        expect(await usdt.balanceOf(user1.address)).to.be.eq(parseUsdt("1000"));
        expect(await usdc.balanceOf(user1.address)).to.be.eq(parseUsdc("1500"));
        expect(await busd.balanceOf(user1.address)).to.be.eq(parseBusd("2000"));
    });

    //  TODO rebalance()
    //    happy paths:
    //    corner cases below:

    // TODO setSupportedToken()
    //   happy paths: add token, token added, is listed in supported tokens
    //    corner cases below:
    //     pass same token multiple times, test function is idempotent
    //     pass address that is not a token
    //   suspended until clarification: happy paths delete token: test
    //     corner cases below:
    //       token is still in already in strategy
});