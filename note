TODO: find out how to deal with dust on strategy after adding liquidity

--------- exchange contract with routing --------- 
1) Needs a function to route swap through predefined dex such as pancakeswap or acryptos, maybe some other in future.
    - this would be useful in strategy router as we may have different stables, some of them can be swapped on acryptos to save on fees and slippage.
2) AcryptoS pool is relatively hard to integrate on-chain.
    - good to know that they have multiple stableswap metapools, and one base pool ACS4USD. We only use UST metapool for now, to add new pools will need to add new DexType, setup coinIds and dexTypes mappings via setter functions. 

So possible implementation in general: 
1) when calling swapRouted we will get DexType for these two tokens. If DexType not set for them we use default route which is pancakeswap with intermediary WETH.
2) Function to swap on certain DexType directly, by passing dex type as argument.

If we need to add more dex types then we should have possibility to replace Exchange contract with new version in every other contract that depends on it.
--------- end --------- 



--------- biswap ust-busd strategy --------- 
biswap router: https://bscscan.com/address/0x3a6d8ca21d1cf76f653a67577fa0d27453350dd8#code
UST: https://bscscan.com/address/0x23396cF899Ca06c4472205fC903bDB4de249D6fC
BSW: https://bscscan.com/address/0x965f527d9159dce6288a2219db51fc6eef120dd1
BUSD: https://bscscan.com/token/0xe9e7cea3dedca5984780bafc599bd69add087d56
PAIR (and lp token): https://bscscan.com/address/0x9E78183dD68cC81bc330CAF3eF84D354a58303B5
farm: https://bscscan.com/address/0xdbc1a13490deef9c3c12b44fe77b503c1b061739

    - deposit -
1) approve router to transfer UST & busd
2) call add_liquidity on router and receive LP tokens

3) approve farm to transfer BSW LP tokens
4) call function on farm: deposit(uint256 _pid, uint256 _amount)
    but first, need to find pid for our lp token though

    - harvest and reinvest -
5) harvest BSW tokens by call to withdraw(uint256 _pid, uint256 _amount) need to pass _amount 0 to harvest
6) swap BSW to more UST & BUSD
7) go to step 1

    - withdraw -
8) call withdraw(uint256 _pid, uint256 _amount) _amount is lp tokens
    strategy-router will provide us amount of usd to withdraw, we need to get its value in LP tokens so we can proceed.
    use formula from here https://cmichel.io/pricing-lp-tokens/

9) swap LP tokens to ust

NOTE: deposit and withdraw functions always harvest BSW tokens if there is any on farm

--------- end --------- 



--------- acryptos ust strategy --------- 
https://app.acryptos.com/contracts/
https://docs.acryptos.com/

ACS4UST pool: https://bscscan.com/address/0x99c92765EfC472a9709Ced86310D64C4573c4b77
ACS4UST zap depositer: https://bscscan.com/address/0x4deb9077e49269b04fd0324461af301dd6600216
ACS4UST LP token: https://bscscan.com/address/0xd3debe4a971e4492d0d61ab145468a5b2c23301b
UST: https://bscscan.com/address/0x23396cF899Ca06c4472205fC903bDB4de249D6fC
ACSI: https://bscscan.com/address/0x5b17b4d5e4009b5c43e3e3d63a5229f794cba389
ACryptoSFarmV4: https://bscscan.com/address/0x0c3b6058c25205345b8f22578b27065a7506671c

    - deposit -
1) approve zap depositer contract to transfer UST
2) call add_liquidity on depositer and receive LP tokens

    function description:
    @notice Wrap underlying coins and deposit them in the pool
    @param amounts List of amounts of underlying coins to deposit
    @param min_mint_amount Minimum amount of LP tokens to mint from the deposit
    @return Amount of LP tokens received by depositing

3) approve ACryptoSFarmV4 to transfer ACS4UST LP tokens
4) call function on ACryptoSFarmV4: deposit(address _lpToken, uint256 _amount)

    - harvest and reinvest -
5) harvest ACS tokens by call to harvest(address _lpToken)
6) swap ACS to more UST
7) go to step 1

    - withdraw -
8) call withdraw(address _lpToken, uint256 _amount) _amount is lp tokens
    strategy-router will provide us amount of usd to withdraw, we need to get its value in LP tokens so we can proceed. because withdraw function takes lp token amount as argument. use calc_token_amount for that.
9) swap LP tokens to ust and transfer

    - totalTokens function -
1) use calc_token_amount function, it says it accounts for slippage but not fees, which should be ok

* Useful function in pool for calculation profits(as they said in the following doc-comments): 
    def get_virtual_price() -> uint256:
    """
    @notice The current virtual price of the pool LP token
    @dev Useful for calculating profits
    @return LP token virtual price normalized to 1e18
    """

-------
if totalTokens uses calc_withdraw_one_coin & calc_token_amount which accounts for slippage, then for 1 LP we get number like 1.099 (and for 1.0 usd we would get 0.99 LP) but if instead we use get_virtual_price to convert LP to tokens and vice versa, then we would get amounts without slippage, the question is which method to use. 

if use calc_withdraw_one_coin and calc_token_amount:

user withdraw 100 tokens, 
use calc_token_amount to convert to LP (accounts for slippage)
withdrawAmount would be 99.9 LP
now user got 99.9 and on farm leftover is 0.1 LP
so from each withdraw there is small leftover ammount.


if use get_virtual_price:

user withdraw 100 tokens, 
use get_virtual_price to convert to LP 
withdrawAmount would be 100 LP (but can it be bigger such as 101.0? not sure, Curve pool math is quite hard)
now user got 100 and on farm leftover is 0.0 LP

test: after withdraw all tokens, only withdraw function has math based on virtual price, lefover on farm
on farm LPs 1425101280499913967, totalTokens 1627105805945261011
(1.4 LP and 1.6 $)

test: all functions based on get_virtual_price
on farm LPs 1, totalTokens 1

looks like get_virtual_price approach works better without problems 

--------- end --------- 